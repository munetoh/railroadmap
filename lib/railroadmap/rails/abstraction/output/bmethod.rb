# -*- coding: UTF-8 -*-
# abstraction => B method
#
#  B Method
#    http://en.wikipedia.org/wiki/B-Method
#  ProB
#    http://www.stups.uni-duesseldorf.de/ProB/index.php5/Main_Page
#
#  probcli
#
# OSX
#  brew install graphviz
#
# TODO: need update to v0.2.0

module Abstraction
  module Output
    # Formal method: B
    class Bmethod
      # Escape bad char for HTML5/JS
      def error(msg)
        $stderr.puts msg
        fail msg if $robust
      end

      def escape(id)
        if id.nil?
          "TBD"  # TODO: raise and skip this trans
        else
          id.gsub(/[#:?!]/, "_")
        end
      end

      # Ruby Guard -> B Pre
      def rg2bp(guard)
        return '' if guard.nil?

        g = guard.sub('(true) and ', '')
        g = g.sub('(TBD)', '')
        g = g.sub('(true)', '')
        g = g.sub('true', 'TRUE')

        g = Regexp.last_match[1] + ' = FALSE' if g =~ /not \(([\w_]+)==TRUE\)/

        if g =~ /not \(([\w_]+)==(\w+)\)/
          g = Regexp.last_match[1] + ' != ' + Regexp.last_match[2]
        elsif g =~ /\(([\w_]+)==(\w+)\)/
          g = Regexp.last_match[1] + ' = ' + Regexp.last_match[2]
        elsif g == ''
          #
        else
          g = ''
        end
        return g
      end

      # Ruby action -> B action
      def ra2ba(action)
        return '' if action.nil?

        a = action.gsub('=', ':=')
        a = a.sub('false', 'FALSE')
        a = a.sub('true', 'TRUE')
        return a
      end

      # Generate B method model
      def output(base_dir)
        # check $map_bset_types
        fail "set $map_bset_types in ./railroadmap/abstraction.rb file" if $map_bset_types.nil?

        # main model
        b_file = base_dir + '/railroadmap.mch'
        open(b_file, "w") do |f|
          f.write "/* Generated by railroadmap */\n"
          f.write "MACHINE railroadmap\n"
          f.write "SETS\n"
          f.write "  USER={user1, user2, anonymous};\n"
          f.write "  EMAIL={email1, email2};\n"
          f.write "  PASSWORD={password1, password2};\n"
          f.write "  FLAG={on, off};\n"
          f.write "  TEXT={text1, text2};\n"
          f.write "  TOKEN={good, bad};\n"
          f.write "  STATE={\n"

          $abst_states.each do |n, s|
            sid = escape(s.id)
            f.write "    #{sid},\n"
          end

          f.write "    root_start, root_end\n"
          f.write "  };\n"
          f.write "  MESSAGE={ok, login_failed, error1, error2}\n"
          f.write "  \n"
          f.write "  \n"
          f.write "CONSTANTS\n"
          f.write "  APPLICATION_USER\n"
          f.write "  \n"
          f.write "  \n"
          f.write "PROPERTIES\n"
          f.write "  APPLICATION_USER <: USER & APPLICATION_USER /= {}\n"
          f.write "  \n"
          f.write "  \n"
          f.write "VARIABLES\n"
          f.write "  user, state, message, signed_in, post_error, save, update, csrf_token\n"
          f.write "  \n"
          f.write "  \n"
          f.write "INVARIANT\n"
          f.write "  user:USER &\n"
          f.write "  state:STATE &\n"
          f.write "  message:MESSAGE &\n"
          f.write "  signed_in:BOOL &\n"
          f.write "  post_error:BOOL &\n"
          f.write "  save:BOOL &\n"
          f.write "  update:BOOL &\n"
          f.write "  csrf_token:TOKEN\n"
          f.write "  \n"
          f.write "  \n"
          # TODO: set by init table?
          f.write "INITIALISATION\n"
          f.write "  user,state,message,signed_in,post_error,save,update,csrf_token "
          f.write ":= anonymous, C_welcome_index, ok, FALSE, FALSE, FALSE, FALSE, good\n"
          f.write "  \n"
          f.write "  \n"

          # OPERATIONS
          f.write "OPERATIONS\n"
          opcnt = 0

          $abst_transitions.each do |n, t|
            if t.invalid == false
              # OPERATION ID
              opid = 't' + opcnt.to_s + '_' + t.type
              # TODO: POST(submit) has more args
              pre1 = ''
              if t.type == 'submit' && t.variables.size > 0
                arg = ''
                t.variables.each do |v|
                  arg <<  v + ', '
                  # TODO: check $map_bset_types
                  v2 = $map_bset_types[v]
                  v2 = 'ruby(' + v + ')' if v2.nil?
                  pre1 << v + ':' + v2 + ' & '
                end
                arg << 'u, dst'  # TODO
              else
                arg = 'u, dst'  # default args
              end

              # TODO: check inconsistent transition. (= BUG)
              if $abst_states[t.src_id].nil?
                # error "#{t.src_id} -> #{t.dst_id}, src is missing, skip or abort"
              elsif $abst_states[t.dst_id].nil?
                # error "#{t.src_id} -> #{t.dst_id}, dst is missing, skip or abort"
              else
                # OK
                src_id = escape(t.src_id)
                dst_id = escape(t.dst_id)

                # Pre condition
                pre = rg2bp(t.block.abst_condition_success)

                # Action
                action = ra2ba($abstmap_action[t.block.id])
                f.write "\n"
                f.write "  #{opid}(#{arg})=\n"
                f.write "  PRE\n"
                f.write "    #{pre1}u:APPLICATION_USER & dst:STATE &\n"

                # before filter authenticated => signed_in = TRUE
                dst = $abst_states[t.dst_id]
                f.write "    signed_in = TRUE &\n" if dst.is_authenticated
                f.write "    #{pre} &\n"           if pre != ''
                f.write "    dst = #{dst_id} &\n"
                f.write "    state = #{src_id}\n"
                f.write "  THEN\n"
                f.write "    #{action} ||\n"       if action != ''
                f.write "    state:=#{dst_id}\n"
                f.write "  END;\n"
              end
              # count all trans
              opcnt = opcnt + 1
            end # if
          end # DO
          f.write "  Dummy(u)=\n"
          f.write "  PRE\n"
          f.write "    u: APPLICATION_USER & state = root_start\n"
          f.write "  THEN\n"
          f.write "     state := root_end\n"
          f.write "  END\n"
          f.write "END\n"
        end # do f
        # LTL
      end
    end
  end
end
